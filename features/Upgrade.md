# Upgrading from rspec-rails-2.x to rspec-rails-3

For detailed information on the RSpec 3.x upgrade process see the [RSpec Upgrade
docs](https://relishapp.com/rspec/docs/upgrade).

There is another `rspec-rails` specific change to be aware of:

```text
The default helper files created in RSpec 3.x have changed
```

In prior versions, only a single `spec_helper.rb` file was generated. This file
has been moved to `rails_helper.rb`. The new `spec_helper.rb` is the same
standard helper generated by running `rspec --init`.

This change was made to accomplish two general goals:

- Keep the installation process in sync with regular RSpec changes

- Provide an out-of-the-box way to avoid loading Rails for those specs that do
  not require it

## Upgrading an Existing App

For most existing apps, one of the following upgrade paths is sufficient to
switch to the new helpers:

### I need to move things over in stages

1. Create a new `rails_helper.rb` with the following content:

    ```ruby
    require 'spec_helper'
    ```

2. As necessary, replace `require 'spec_helper'` with `require 'rails_helper'`
   in the specs.

3. When ready, move any Rails specific code and setup from `spec_helper.rb` to
   `rails_helper.rb`.

### I'm ready to just switch completely

1. Move the existing `spec_helper.rb` to `rails_helper.rb`:

    ```ruby
    git move spec/spec_helper.rb spec/rails_helper.rb
    ```

2. Run the installation rake task opting to not replace `rails_helper.rb`:

    ```console
    $ bin/rails generate rspec:install
          create  .rspec
           exist  spec
          create  spec/spec_helper.rb
        conflict  spec/rails_helper.rb
    Overwrite my_app/spec/rails_helper.rb? (enter "h"for help) [Ynaqdh] n
            skip  spec/rails_helper.rb
    ```

3. Move any non-Rails RSpec configurations and customizations from your
   `rails_helper.rb` to `spec_helper.rb`.

4. Find/replace instances of `require 'spec_helper'` with
   `require 'rails_helper'` in any specs which rely on Rails.

## Generators

Generators run in RSpec 3.x will use the `rails_helper` by default.

# Upgrading from rspec-rails-1.x to rspec-rails-2

This is a work in progress. Please submit errata, missing steps, or patches to
the [rspec-rails issue tracker](https://github.com/rspec/rspec-rails/issues).

## Rake tasks

Delete lib/tasks/rspec.rake, if present. Rake tasks now live in the rspec-rails
gem.

## `spec_helper.rb`

There were a few changes to the generated `spec/spec_helper.rb` file. We
recommend the following:

1. set aside a copy of your existing `spec/spec_helper.rb` file.
2. run `rails generate rspec:install`
3. copy any customizations from your old spec_helper to the new one

If you prefer to make the changes manually in the existing spec_helper, here
is what you need to change:

    # rspec-1
    require 'spec/autorun'

    Spec::Runner.configure do |config|
      ...
    end

    # rspec-2
    require 'rspec/rails'

    RSpec.configure do |config|
      ...
    end

## Controller specs

### isolation from view templates

By default, controller specs do _not_ render view templates. This keeps
controller specs isolated from the content of views and their requirements.

NOTE that the template must exist, but it will not be rendered.  This is
different from rspec-rails-1.x, in which the template didn't need to exist, but
ActionController makes a number of new decisions in Rails 3 based on the
existence of the template. To keep the RSpec code free of monkey patches, and
to keep the rspec user experience simpler, we decided that this would be a fair
trade-off.

### `response.should render_template`

This needs to move from before the action to after. For example:

    # rspec-rails-1
    controller.should render_template("edit")
    get :edit, :id => "37"

    # rspec-rails-2
    get :edit, :id => "37"
    response.should render_template("edit")

    # rspec-rails-2 with expect syntax
    get :edit, :id => "37"
    expect(response).to render_template("edit")

rspec-1 had to monkey patch Rails to get render_template to work before the
action, and this broke a couple of times with Rails releases (requiring urgent
fix releases in RSpec). Part of the philosophy of rspec-rails-2 is to rely on
public APIs in Rails as much as possible. In this case, `render_template`
delegates directly to Rails' `assert_template`, which only works after the
action.

## View specs

### `view.should render_template`

Rails changed the way it renders partials, so to set an expectation that a
partial gets rendered, you need

    render
    view.should render_template(:partial => "widget/_row")

### stub_template

Introduced in rspec-rails-2.2, simulates the presence of view templates on the
file system. This supports isolation from partials rendered by the vew template
that is the subject of a view example:

    stub_template "widgets/_widget.html.erb" => "This Content"

### No more `have_tag` or `have_text`

Before Webrat came along, rspec-rails had its own `have_tag` and `have_text`
matchers that wrapped Rails' `assert_select`. Webrat included replacements for
these methods, as well as new matchers (`have_selector` and `have_xpath`), all
of which rely on Nokogiri to do its work, and are far less brittle than RSpec's
`have_tag`.

Capybara has similar matchers, which will soon be available view specs (they
are already available in controller specs with `render_views`).

Given the brittleness of RSpec's `have_tag` and `have_text` matchers and the
presence of new Webrat and Capybara matchers that do a better job, `have_tag`
and `have_text` were not included in rspec-rails-2.

## Mocks, stubs, doubles

### as_new_record

Earlier versions of the view generators generated stub_model with `:new_record?
=> true`. That is no longer recognized in rspec-rails-2, so you need to change
this:

    stub_model(Widget, :new_record? => true)

to this:

    stub_model(Widget).as_new_record

Generators in 2.0.0 final release will do the latter.
